<h2 id="intro" class="list">Introduction <span class="backlink"> back to <a href="#toc">ToC</a></span></h2>
<span>
    This ontology provides a semantic vocabulary for documenting AI systems and their lifecycle. 
    Use the classes and properties defined here to create RDF graphs describing AI systems, their components (models, datasets), activities (training, deployment), and responsible agents (providers, deployers). The ontology extends W3C PROV and integrates with existing standards.
    <br>
    <b>Note:</b> This documentation is currently under construction and in active development. The content presented here is not final and may change significantly.
</span>

<h3 id="terms" class="list">Terminology</h3>
<span>
    An Application Profile is a data specification aimed to facilitate the data exchange in a well-defined application context. It re-uses concepts from one or more semantic data specifications, while adding more specificity, by identifying mandatory, recommended, and optional elements, addressing particular application needs, and providing recommendations for controlled vocabularies to be used.
    More information can be found on the <a href="https://semiceu.github.io/style-guide/1.0.0/terminological-clarifications.html#sec:what-is-an-ap-specification">SEMIC Style Guide</a>.
</span>


<h3 id="additional-resources" class="list">Additional Resources</h3>
<span>Explore additional resources linked to the AIDOCâ€‘AP ontology.</span>

<style>
.resource-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin: 20px 0;
}
.resource-card {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 20px;
  background: #f9f9f9;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}
.resource-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  transform: translateY(-2px);
  border-color: #0066cc;
}
.resource-card h4 {
  margin: 0 0 10px 0;
  color: #0066cc;
  font-size: 1.2em;
}
.resource-card p {
  margin: 10px 0;
  color: #555;
  font-size: 0.95em;
  line-height: 1.5;
}
.resource-card .stats {
  display: flex;
  gap: 15px;
  margin: 15px 0 10px 0;
  flex-wrap: wrap;
}
.resource-card .stat-badge {
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 5px 12px;
  font-size: 0.85em;
  color: #333;
  white-space: nowrap;
}
.resource-card .stat-badge strong {
  color: #0066cc;
  font-size: 1.1em;
}
.resource-card .cta {
  display: inline-block;
  margin-top: 10px;
  color: #0066cc;
  text-decoration: none;
  font-weight: 500;
}
.resource-card .cta:hover {
  text-decoration: underline;
}
.resource-card .icon {
  position: absolute;
  top: 15px;
  right: 15px;
  font-size: 2em;
  opacity: 0.1;
}
</style>

<div class="resource-cards">
  <div class="resource-card">
    <span class="icon">ðŸ“‹</span>
    <h4><a href="requirements.html">AI Act Requirements</a></h4>
    <p>List of technical documentation requirements extracted from EU AI Act Annex IV, with descriptions, lifecycle stages, and competency questions.</p>
    <div class="stats">
      <span class="stat-badge"><strong id="req-count">28</strong> requirements</span>
      <span class="stat-badge"><strong id="cq-count">â€”</strong> competency questions</span>
    </div>
    <a href="requirements.html" class="cta">View all requirements â†’</a>
  </div>

  <div class="resource-card">
    <span class="icon">ðŸ“Š</span>
    <h4><a href="coverage.html">Coverage Analysis</a></h4>
    <p>LLMâ€‘based assessment evaluating how well AIDOCâ€‘AP covers EU AI Act Annex IV requirements, with detailed reasoning and gap analysis.</p>
    <div class="stats">
      <span class="stat-badge"><strong id="cov-avg">â€”</strong> avg coverage</span>
      <span class="stat-badge"><strong id="cov-high">â€”</strong> excellent (â‰¥90%)</span>
    </div>
    <a href="coverage.html" class="cta">View coverage analysis â†’</a>
  </div>

  <div class="resource-card">
    <span class="icon">ðŸ”—</span>
    <h4><a href="alignments.html">Crossâ€‘Ontology Alignments</a></h4>
    <p>Mappings between AIDOCâ€‘AP terms and external ontologies (AIRO, MLâ€‘Schema, PROVâ€‘O, etc.) with relation types, confidence scores, and provenance.</p>
    <div class="stats">
      <span class="stat-badge"><strong id="align-count">â€”</strong> mappings</span>
      <span class="stat-badge"><strong id="align-ontos">â€”</strong> ontologies</span>
    </div>
    <a href="alignments.html" class="cta">View alignments â†’</a>
  </div>
</div>

<script>
// Dynamically load stats for each resource
(async function loadResourceStats(){
  // Load requirements count and CQs
  try {
    const resp = await fetch('resources/annex_4.ttl');
    const txt = await resp.text();
    const cqMatches = txt.match(/aiact:cq\d+_\d+/g);
    if (cqMatches) {
      document.getElementById('cq-count').textContent = new Set(cqMatches).size;
    }
  } catch(e) { console.log('Could not load requirements stats'); }

  // Load coverage stats
  try {
    const resp = await fetch('resources/semantic_mapping.ttl');
    if (resp.ok) {
      const txt = await resp.text();
      const valueMatches = txt.match(/dqv:value\s+"?([0-9.]+)"?/g);
      if (valueMatches) {
        const scores = valueMatches.map(m => parseFloat(m.match(/([0-9.]+)/)[1]));
        const avg = scores.reduce((a,b)=>a+b,0) / scores.length;
        const high = scores.filter(s => s >= 0.9).length;
        document.getElementById('cov-avg').textContent = (avg * 100).toFixed(0) + '%';
        document.getElementById('cov-high').textContent = high;
      }
    }
  } catch(e) { console.log('Could not load coverage stats'); }

  // Load alignment stats
  try {
    const manifestResp = await fetch('resources/alignments-manifest.json');
    if (manifestResp.ok) {
      const manifest = await manifestResp.json();
      const files = manifest.files || [];
      document.getElementById('align-ontos').textContent = files.length;
      
      // Count total mappings across all files
      let totalMappings = 0;
      for (const file of files) {
        try {
          const resp = await fetch(file);
          const txt = await resp.text();
          const mappingMatches = txt.match(/a\s+alignment:Mapping/g);
          if (mappingMatches) {
            totalMappings += mappingMatches.length;
          }
        } catch(e) { /* skip */ }
      }
      if (totalMappings > 0) {
        document.getElementById('align-count').textContent = totalMappings;
      }
    }
  } catch(e) { console.log('Could not load alignment stats'); }
})();
</script>

